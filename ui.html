<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ArtyColors</title>
  <style>
    :root {
      /* Colors */
      --bg: #F9FAFB;
      --surface: #FFFFFF;
      --border: #E5E7EB;
      --text: #111827;
      --muted: #6B7280;
      --disabled: #9CA3AF;

      --brand-600: #1D4ED8;
      --brand-700: #1E40AF;
      --focus-ring: rgba(29,78,216,.35);

      /* Radii & shadow */
      --radius: 8px;
      --radius-sm: 4px;
      --shadow-1: 0 1px 2px rgba(0,0,0,.06), 0 1px 1px rgba(0,0,0,.04);

      /* Spacing (8-pt) */
      --s-1: 4px; --s-2: 8px; --s-3: 12px; --s-4: 16px; --s-5: 20px; --s-6: 24px;

      /* Typography */
      --font-sans: Inter, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      --font-mono: ui-monospace, SFMono-Regular, Menlo, monospace;

      --fs-h1: 16px;
      --fs-label: 12px;
      --fs-body: 13px;
      --lh: 1.4;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: var(--fs-body)/var(--lh) var(--font-sans);
    }
    
    h1 {
      font-size: var(--fs-h1);
      font-weight: 600;
      margin: var(--s-4) 0 var(--s-3);
    }
    
    .section-label {
      font-size: var(--fs-label);
      font-weight: 500;
      color: var(--muted);
      margin-bottom: var(--s-2);
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow-1);
    }

    .input, .button, .pill, .tab-btn {
      border-radius: var(--radius);
      border: 1px solid var(--border);
    }

    input[type="text"], select, .input {
      height: 36px;
      padding: 0 var(--s-3);
      background: var(--surface);
      color: var(--text);
      width: 100%;
      box-sizing: border-box;
      cursor: pointer;
    }

    input::placeholder {
      color: var(--muted);
    }

    :focus-visible {
      outline: 2px solid var(--focus-ring);
      outline-offset: 2px;
      border-color: transparent;
    }

    .tabs {
      display: flex;
      gap: var(--s-4);
      padding: var(--s-3) var(--s-4) var(--s-2);
      border-bottom: 1px solid var(--border);
      background: var(--surface);
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .tab-btn {
      border: none;
      background: transparent;
      color: var(--muted);
      padding: var(--s-2) 0;
      position: relative;
      font-weight: 500;
      cursor: pointer;
    }

    .tab-btn[aria-selected="true"] {
      color: var(--text);
    }

    .tab-btn[aria-selected="true"]::after {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      bottom: -10px;
      height: 2px;
      background: var(--brand-600);
      border-radius: 2px;
    }
    
    .tab-content {
      display: none;
      padding: var(--s-4);
    }
    
    .tab-content.active {
      display: block;
    }
    
    .section {
      margin-bottom: var(--s-6);
    }
    
    .section:last-child {
      margin-bottom: 0;
    }
    
    .button.primary {
      background: var(--brand-600);
      color: #fff;
      border: none;
      height: 40px;
      padding: 0 var(--s-5);
      border-radius: var(--radius);
      box-shadow: var(--shadow-1);
      cursor: pointer;
      font-weight: 500;
      width: 100%;
    }

    .button.primary:hover {
      background: var(--brand-700);
    }

    .button.primary:active {
      filter: brightness(.96);
    }

    .button.primary:disabled {
      background: #93C5FD;
      cursor: not-allowed;
    }

    .button.secondary {
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      height: 36px;
      padding: 0 var(--s-4);
      border-radius: var(--radius);
      cursor: pointer;
      font-weight: 500;
      width: 100%;
    }

    .button.secondary:hover {
      background: #F9FAFB;
    }

    .input-group {
      margin-bottom: var(--s-3);
    }

    .input-group label {
      display: block;
      font-size: var(--fs-label);
      font-weight: 500;
      color: var(--muted);
      margin-bottom: var(--s-2);
    }

    .workflow-step {
      background: #F3F4F6;
      padding: var(--s-3);
      border-radius: var(--radius);
      margin-bottom: var(--s-3);
      font-size: var(--fs-label);
      color: var(--muted);
      line-height: var(--lh);
    }

    /* Detected Colors List */
    .list {
      padding: var(--s-2);
    }

    .row {
      display: grid;
      grid-template-columns: 24px auto 1fr;
      align-items: center;
      gap: var(--s-3);
      padding: var(--s-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--surface);
      min-height: 40px;
      opacity: 0;
      transform: translateY(4px);
      animation: fadeIn .18s ease-out forwards;
    }

    .row.color-picker {
      grid-template-columns: 24px auto 1fr 32px;
    }

    .row + .row {
      margin-top: var(--s-2);
    }

    .swatch {
      width: 24px;
      height: 24px;
      border-radius: var(--radius-sm);
      border: 1px solid #D1D5DB;
    }

    .pill.hex {
      font-family: var(--font-mono);
      font-size: 12px;
      padding: 2px 8px;
      border-radius: var(--radius-sm);
      background: #F3F4F6;
      color: var(--text);
      border: 1px solid var(--border);
      white-space: nowrap;
    }

    .name {
      width: 100%;
      height: 32px;
      padding: 0 var(--s-2);
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      font-size: var(--fs-body);
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
        transform: none;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .row {
        animation: none;
        opacity: 1;
        transform: none;
      }
    }

    /* Sticky Save Area */
    .savebar {
      position: sticky;
      bottom: 0;
      background: var(--surface);
      padding: var(--s-3) var(--s-4);
      border-top: 1px solid var(--border);
      display: grid;
      gap: var(--s-2);
    }

    .savebar-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: var(--s-3);
    }

    /* Toast notifications */
    .toast {
      position: fixed;
      bottom: var(--s-4);
      left: var(--s-4);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow-1);
      padding: var(--s-3) var(--s-4);
      font-size: var(--fs-body);
      color: var(--text);
      z-index: 1000;
      opacity: 0;
      transform: translateY(8px);
      transition: all 0.2s ease-out;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }

    .toast.success {
      border-left: 3px solid #10B981;
    }

    .toast.error {
      border-left: 3px solid #EF4444;
    }
    
    .role-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .role-button {
      padding: 8px 12px;
      border: 1px solid #d0d0d0;
      background: white;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    
    .role-button:hover {
      background: #f5f5f5;
      border-color: #999;
    }
    
    .role-button.base { border-color: #007ACC; color: #007ACC; }
    .role-button.role-a { border-color: #FF6B35; color: #FF6B35; }
    .role-button.role-b { border-color: #4ECDC4; color: #4ECDC4; }
    .role-button.role-c { border-color: #FFE66D; color: #FFE66D; }
    
    .role-button.base:hover { background: #E3F2FD; }
    .role-button.role-a:hover { background: #FFF3F0; }
    .role-button.role-b:hover { background: #F0FDFC; }
    .role-button.role-c:hover { background: #FFFEF5; }
    
    .input-group {
      margin-bottom: 12px;
    }
    
    .input-group label {
      display: block;
      margin-bottom: 4px;
      font-size: 11px;
      color: #666;
      font-weight: 500;
    }
    
    .input-group input, .input-group select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      font-size: 12px;
      box-sizing: border-box;
    }
    
    .primary-button, .secondary-button {
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
      margin-bottom: 8px;
    }
    
    .primary-button {
      background: #007ACC;
      color: white;
    }
    
    .primary-button:hover {
      background: #0066AA;
    }
    
    .primary-button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .secondary-button {
      background: white;
      color: #333;
      border: 1px solid #d0d0d0;
    }
    
    .secondary-button:hover {
      background: #f5f5f5;
    }
    

    
    .color-input {
      width: 60px !important;
      height: 32px !important;
      padding: 2px !important;
      border: 1px solid #d0d0d0 !important;
      border-radius: 4px !important;
      cursor: pointer !important;
    }
    
    .empty-state {
      text-align: center;
      padding: 20px;
      color: #666;
      font-size: 11px;
      font-style: italic;
    }
    
    .status-message {
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 12px;
      font-size: 11px;
      font-weight: 500;
    }
    
    .status-message.success {
      background: #E8F5E8;
      color: #2E7D32;
      border: 1px solid #C8E6C9;
    }
    
    .status-message.error {
      background: #FFEBEE;
      color: #C62828;
      border: 1px solid #FFCDD2;
    }
    
    .workflow-step {
      background: #f8f9fa;
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 8px;
      font-size: 11px;
      color: #666;
      line-height: 1.4;
    }
    
    .color-list {
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .color-item {
      display: flex;
      align-items: center;
      padding: 8px 10px;
      border-bottom: 1px solid #e0e0e0;
      gap: 10px;
    }
    
    .color-item:last-child {
      border-bottom: none;
    }
    
    .color-swatch {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid #d0d0d0;
      flex-shrink: 0;
    }
    
    .color-hex {
      font-size: 10px;
      color: #666;
      font-family: monospace;
      font-weight: 500;
      width: 60px;
      flex-shrink: 0;
    }
    
    .color-layer-name {
      font-size: 11px;
      font-weight: 500;
      color: #333;
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .color-name-input {
      flex: 1;
      padding: 4px 8px;
      border: 1px solid #d0d0d0;
      border-radius: 3px;
      font-size: 11px;
      background: white;
      color: #333;
      min-width: 0;
    }
    
    .color-name-input:focus {
      outline: none;
      border-color: #007ACC;
      box-shadow: 0 0 0 1px #007ACC;
    }
    
    .color-name-display {
      flex: 1;
      font-size: var(--fs-body);
      font-weight: 500;
      color: var(--text);
      min-width: 0;
    }
    
    .color-picker-input {
      width: 32px;
      height: 24px;
      padding: 2px;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      cursor: pointer;
      flex-shrink: 0;
    }
    
    .status-text {
      font-size: 10px;
      color: var(--muted);
      font-style: italic;
    }
    
    .variant-row {
      display: flex;
      align-items: center;
      gap: var(--s-2);
      margin-bottom: var(--s-2);
      padding: var(--s-2);
      background: var(--surface);
      border-radius: var(--radius);
      border: 1px solid var(--border);
    }
    
    .variant-number {
      font-size: var(--fs-label);
      font-weight: 600;
      color: var(--muted);
      min-width: 24px;
      text-align: center;
      flex-shrink: 0;
    }
    
    .variant-anchor-dropdown {
      flex: 1;
      height: 32px !important;
      min-width: 90px;
      font-size: var(--fs-body) !important;
    }
    
    .variant-color-input {
      width: 70px;
      height: 32px !important;
      font-family: var(--font-mono);
      font-size: var(--fs-label) !important;
    }
    
    .remove-variant-btn {
      background: #EF4444;
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      width: 24px;
      height: 24px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .remove-variant-btn:hover {
      background: #DC2626;
    }
  </style>
</head>
<body>
  <div role="tablist" aria-label="Modes" class="tabs">
    <button role="tab" aria-selected="true" class="tab-btn" data-tab="create">Create template</button>
    <button role="tab" aria-selected="false" class="tab-btn" data-tab="apply">Apply template</button>
  </div>

  <!-- Create Template Tab -->
  <div class="tab-content active" id="create-tab">
    <div class="section">
      <h1>Create template</h1>
      <div class="workflow-step">
        Select a component or group to automatically detect colors and assign color names
      </div>
      <button class="button primary" id="analyze-selection">Analyze selection</button>
      
      <div id="analysis-results" style="display: none; margin-top: var(--s-6);">
        <div class="input-group">
          <label class="section-label">Detected colors</label>
          <div class="card list" id="color-list">
            <!-- Colors will be populated here -->
          </div>
        </div>
        
        <footer class="savebar" id="save-template-inline">
          <label class="section-label" for="template-name">Save template as</label>
          <div class="savebar-row">
            <input id="template-name" class="input" placeholder="e.g., Button primary" />
            <button class="button primary" id="create-template" style="width: auto; min-width: 80px;">Save</button>
          </div>
        </footer>
      </div>
    </div>
  </div>

  <!-- Apply Template Tab -->
  <div class="tab-content" id="apply-tab">
    <div class="section">
      <h1>Apply template</h1>
      <div class="workflow-step">
        Choose a template to apply to selected components
      </div>
      
      <div class="input-group">
        <label for="template-dropdown">Template</label>
        <select id="template-dropdown" class="input">
          <option value="">Select a template...</option>
        </select>
      </div>
    </div>

    <div class="section" id="color-picker-section" style="display: none;">
      <h1>Choose colors</h1>
      <div class="workflow-step">
        Pick which colors to change - others will adjust relatively
      </div>
      
      <div class="input-group">
        <label class="section-label">Template colors</label>
        <div class="card list" id="template-colors">
          <!-- Template color pickers will be populated here -->
        </div>
      </div>
      
      <button class="button primary" id="apply-template" disabled>Apply to selection</button>
    </div>

    <div class="section" id="batch-section" style="display: none;">
      <h1>Batch generation</h1>
      <div class="workflow-step">
        Create multiple variants by changing different colors
      </div>
      
      <div class="input-group">
        <label class="section-label">Variants to generate</label>
        <div class="card list" id="variant-list">
          <!-- Variant rows will be populated here -->
        </div>
        <button class="button secondary" id="add-variant" style="margin-top: var(--s-2);">+ Add variant</button>
      </div>
      
      <button class="button primary" id="batch-generate" disabled>Generate variants</button>
    </div>
  </div>




<script>
    let selectedTemplateId = null;
    let templates = {};
    let currentLayerColors = [];
    let templateColors = {};

    // Tab switching with proper ARIA and keyboard support
    document.querySelectorAll('.tab-btn').forEach((tab, index, tabs) => {
      tab.onclick = () => switchTab(tab);
      
      tab.onkeydown = (e) => {
        let targetIndex = index;
        
        switch (e.key) {
          case 'ArrowLeft':
            targetIndex = Math.max(0, index - 1);
            break;
          case 'ArrowRight':
            targetIndex = Math.min(tabs.length - 1, index + 1);
            break;
          case 'Home':
            targetIndex = 0;
            break;
          case 'End':
            targetIndex = tabs.length - 1;
            break;
          case 'Enter':
          case ' ':
            switchTab(tab);
            return;
          default:
            return;
        }
        
        e.preventDefault();
        tabs[targetIndex].focus();
        switchTab(tabs[targetIndex]);
      };
    });
    
    function switchTab(tab) {
      const tabName = tab.getAttribute('data-tab');
      
      // Update ARIA states
      document.querySelectorAll('.tab-btn').forEach(t => t.setAttribute('aria-selected', 'false'));
      document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
      
      tab.setAttribute('aria-selected', 'true');
      document.getElementById(tabName + '-tab').classList.add('active');
      
      // Load templates when switching to apply tab
      if (tabName === 'apply') {
        postMessage('get-templates');
      }
    }

    // Analyze selection
    document.getElementById('analyze-selection').onclick = () => {
      postMessage('analyze-selection');
    };

    // Template creation
    document.getElementById('create-template').onclick = () => {
      const templateName = document.getElementById('template-name').value.trim();
      if (!templateName) {
        showStatus('Please enter a template name', 'error');
        return;
      }
      
      if (currentLayerColors.length === 0) {
        showStatus('Please analyze a selection first', 'error');
        return;
      }
      

      postMessage('create-template', { templateName, layerColors: currentLayerColors });
      document.getElementById('template-name').value = '';
    };

    // Enter key support for template name
    document.getElementById('template-name').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !document.getElementById('create-template').disabled) {
        document.getElementById('create-template').click();
      }
    });

    // Template application
    document.getElementById('apply-template').onclick = () => {
      if (!selectedTemplateId) {
        showStatus('Please select a template', 'error');
        return;
      }
      
      // Collect color changes from the UI
      const colorChanges = {};
      Object.keys(templateColors).forEach(role => {
        const input = document.getElementById(`color-${role.toLowerCase()}`);
        if (input) {
          colorChanges[role] = input.value;
        }
      });
      
      postMessage('apply-template', { 
        templateId: selectedTemplateId, 
        colorChanges 
      });
    };

    // Template dropdown change handler
    document.getElementById('template-dropdown').onchange = (e) => {
      const templateId = e.target.value;
      if (templateId) {
        selectTemplate(templateId);
      } else {
        hideColorPickers();
        hideBatchSection();
      }
    };

    // Add variant button
    document.getElementById('add-variant').onclick = () => {
      addVariantRow();
    };

    // Batch generation
    document.getElementById('batch-generate').onclick = () => {
      if (!selectedTemplateId) {
        showStatus('Please select a template', 'error');
        return;
      }

      const variants = collectVariantData();
      
      if (variants.length === 0) {
        showStatus('Please add at least one variant', 'error');
        return;
      }

      // Validate all variants have valid hex colors
      const invalidVariants = variants.filter(v => !v.hexColor.match(/^#[0-9a-fA-F]{6}$/));
      if (invalidVariants.length > 0) {
        showStatus('Please provide valid hex colors for all variants', 'error');
        return;
      }

      postMessage('batch-generate', { 
        templateId: selectedTemplateId, 
        variants
      });
    };



    // Helper functions
    function postMessage(type, data = {}) {
      parent.postMessage({ 
        pluginMessage: { type, ...data } 
      }, '*');
    }

    function showStatus(message, type = 'success') {
      // Create toast notification
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      
      document.body.appendChild(toast);
      
      // Trigger animation
      requestAnimationFrame(() => {
        toast.classList.add('show');
      });
      
      // Remove after 3 seconds
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 200);
      }, 3000);
    }

    function displayAnalysisResults(layerColors) {
      currentLayerColors = layerColors;
      const resultsEl = document.getElementById('analysis-results');
      const colorListEl = document.getElementById('color-list');
      
      if (layerColors.length === 0) {
        resultsEl.style.display = 'none';
        document.getElementById('create-template').disabled = true;
        return;
      }
      
      resultsEl.style.display = 'block';
      colorListEl.innerHTML = '';
      
      layerColors.forEach((layerColor, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'row';
        
        itemEl.innerHTML = `
          <span class="swatch" style="--sw:${layerColor.color}; background: var(--sw);"></span>
          <span class="pill hex">${layerColor.color.toUpperCase()}</span>
          <input class="input name" type="text" value="${layerColor.layerName}" data-node-id="${layerColor.nodeId}" data-role="${layerColor.role}" aria-label="Color role name" placeholder="Color name">
        `;
        
        // Handle name change
        const nameInput = itemEl.querySelector('.name');
        nameInput.onchange = nameInput.onblur = (e) => {
          const newName = e.target.value.trim() || layerColor.layerName; // Fallback to original name
          const nodeId = e.target.getAttribute('data-node-id');
          
          // Update local data
          const layerIndex = currentLayerColors.findIndex(lc => lc.nodeId === nodeId);
          if (layerIndex >= 0) {
            currentLayerColors[layerIndex].displayName = newName;
          }
          
          e.target.value = newName; // Ensure input shows the final name
        };
        
        colorListEl.appendChild(itemEl);
      });
      
      // Enable template creation
      document.getElementById('create-template').disabled = false;
    }

    function updateTemplateList(templatesData) {
      templates = templatesData;

      
      const dropdown = document.getElementById('template-dropdown');
      
      // Clear existing options (keep the default one)
      dropdown.innerHTML = '<option value="">Select a template...</option>';
      
      if (Object.keys(templates).length === 0) {
        hideColorPickers();
        return;
      }
      
      // Add template options
      for (const [id, template] of Object.entries(templates)) {

        const option = document.createElement('option');
        option.value = id;
        option.textContent = template.name;
        dropdown.appendChild(option);
      }
      
      updateApplyButton();
    }

    function selectTemplate(id) {
      selectedTemplateId = id;
      updateTemplateList(templates);
      showColorPickers(templates[id]);
      showBatchSection();
    }

    function showColorPickers(template) {
      const section = document.getElementById('color-picker-section');
      const container = document.getElementById('template-colors');
      
      if (!template) {
        hideColorPickers();
        return;
      }
      

      
      // Clear existing pickers
      container.innerHTML = '';
      templateColors = {};
      
      // Check if template has original colors
      if (template.originalColors && Object.keys(template.originalColors).length > 0) {
        console.log('Found original colors:', template.originalColors);
        // Use original colors from template
        Object.keys(template.originalColors).forEach(role => {
          templateColors[role] = template.originalColors[role];
        });
      } else {
        console.log('No original colors found, template keys:', Object.keys(template));
        console.log('Template roles:', template.roles);
        console.log('Template colorNames:', template.colorNames);
        
        // Fallback to default colors if original colors don't exist (for old templates)
        templateColors['Base'] = '#007ACC';
        
        // Generate some default colors for roles based on base
        // Generate default colors for all roles (including Base)
        const allRoles = Object.keys(template.originalColors || {});
        allRoles.forEach((role, index) => {
          // Create different default colors for each role
          const hue = (220 + index * 60) % 360;
          templateColors[role] = hslToHex(hue, 60, 50);
        });
      }
      
      // Create UI for each color (Base first, then others in original template order)
      const baseRoles = templateColors['Base'] ? ['Base'] : [];
      const otherRoles = Object.keys(templateColors).filter(r => r !== 'Base');
      const allRoles = [...baseRoles, ...otherRoles];
      
      allRoles.forEach(role => {
        const colorRow = document.createElement('div');
        colorRow.className = 'row color-picker';
        
        // Use stored display name or fallback to role name
        const displayName = template.colorNames?.[role] || (role === 'Base' ? 'Base Color' : 'Role ' + role);
        const currentColor = templateColors[role];
        
        const hasOriginalColors = template.originalColors && Object.keys(template.originalColors).length > 0;
        const statusText = role === 'Base' ? 'Primary color' : (hasOriginalColors ? 'Original color' : 'Default color');
        
        colorRow.innerHTML = `
          <span class="swatch" style="--sw:${currentColor}; background: var(--sw);"></span>
          <span class="pill hex" id="hex-${role.toLowerCase()}">${currentColor.toUpperCase()}</span>
          <div class="color-name-display">
            ${displayName}
            <div class="status-text">${statusText}</div>
          </div>
          <input type="color" id="color-${role.toLowerCase()}" class="color-picker-input" value="${currentColor}" data-role="${role}">
        `;
        
        // Add real-time change handler
        const colorInput = colorRow.querySelector('.color-picker-input');
        colorInput.addEventListener('input', (e) => {
          const newColor = e.target.value;
          
          // Update the hex pill
          const hexPill = document.getElementById(`hex-${role.toLowerCase()}`);
          if (hexPill) {
            hexPill.textContent = newColor.toUpperCase();
          }
          
          // Update the swatch
          const swatch = colorRow.querySelector('.swatch');
          if (swatch) {
            swatch.style.setProperty('--sw', newColor);
          }
          
          handleColorChange(role, newColor, template);
        });
        
        container.appendChild(colorRow);
      });
      
      section.style.display = 'block';
      updateApplyButton();
    }
    
    function calculateRelativeColor(rule, baseColor) {
      // Simplified OKLCH-like calculation for better color accuracy
      const hex = baseColor.replace('#', '');
      let r = parseInt(hex.substr(0, 2), 16) / 255;
      let g = parseInt(hex.substr(2, 2), 16) / 255;
      let b = parseInt(hex.substr(4, 2), 16) / 255;
      
      // Apply gamma correction (approximate sRGB to linear)
      r = r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
      g = g <= 0.04045 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
      b = b <= 0.04045 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
      
      // Better lightness calculation (closer to L*)
      const lightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;
      
      // Apply lightness changes
      let newLightness = lightness;
      if (rule.Lmode === 'lighten') {
        newLightness = Math.min(1, lightness + rule.k);
      } else {
        newLightness = Math.max(0, lightness - rule.k);
      }
      
      // Apply ratio to all channels
      const ratio = lightness > 0.001 ? newLightness / lightness : 1;
      let newR = r * ratio;
      let newG = g * ratio;
      let newB = b * ratio;
      
      // Apply chroma adjustments (simplified)
      if (rule.Cmul !== 1) {
        const avgChannel = (newR + newG + newB) / 3;
        newR = avgChannel + (newR - avgChannel) * rule.Cmul;
        newG = avgChannel + (newG - avgChannel) * rule.Cmul;
        newB = avgChannel + (newB - avgChannel) * rule.Cmul;
      }
      
      // Clamp values
      newR = Math.max(0, Math.min(1, newR));
      newG = Math.max(0, Math.min(1, newG));
      newB = Math.max(0, Math.min(1, newB));
      
      // Convert back to sRGB
      newR = newR <= 0.0031308 ? newR * 12.92 : 1.055 * Math.pow(newR, 1/2.4) - 0.055;
      newG = newG <= 0.0031308 ? newG * 12.92 : 1.055 * Math.pow(newG, 1/2.4) - 0.055;
      newB = newB <= 0.0031308 ? newB * 12.92 : 1.055 * Math.pow(newB, 1/2.4) - 0.055;
      
      // Convert to hex
      const toHex = (c) => Math.round(Math.max(0, Math.min(255, c * 255))).toString(16).padStart(2, '0');
      return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
    }
    
    function handleColorChange(changedRole, newColor, template) {
      // Update the color that was changed
      templateColors[changedRole] = newColor;
      
      // ANCHOR-BASED RELATIVITY: The changed color becomes the anchor
      // Calculate equal shifts for all other colors
      
      const originalChangedColor = template.originalColors[changedRole];
      if (!originalChangedColor) {
        console.warn('No original color found for', changedRole);
        return;
      }
      
      // Calculate the shift from original to new color
      const colorShift = calculateColorShift(originalChangedColor, newColor);

      
      // Apply equal shifts to all other colors
      Object.keys(template.originalColors).forEach(role => {
        if (role !== changedRole) { // Don't recalculate the anchor color
          const originalColor = template.originalColors[role];
          const shiftedColor = applyColorShift(originalColor, colorShift, 1.0); // Equal 100% shift for all
          templateColors[role] = shiftedColor;
          
          // Update the color input visual
          const input = document.getElementById(`color-${role.toLowerCase()}`);
          if (input) {
            input.value = shiftedColor;
          }
          
          // Update the hex pill
          const hexPill = document.getElementById(`hex-${role.toLowerCase()}`);
          if (hexPill) {
            hexPill.textContent = shiftedColor.toUpperCase();
          }
          
          // Update the swatch
          const swatch = input.closest('.row').querySelector('.swatch');
          if (swatch) {
            swatch.style.setProperty('--sw', shiftedColor);
          }
        }
      });
      
      // Update status texts
      Object.keys(templateColors).forEach(role => {
        const roleElement = document.getElementById(`color-${role.toLowerCase()}`).closest('.row');
        const statusElement = roleElement.querySelector('.status-text');
        if (statusElement) {
          if (role === changedRole) {
            statusElement.textContent = 'Anchor (changed)';
            statusElement.style.color = 'var(--brand-600)';
          } else {
            statusElement.textContent = 'Shifted equally';
            statusElement.style.color = 'var(--muted)';
          }
        }
      });
    }
    
    function calculateColorShift(originalHex, newHex) {
      // Convert both colors to HSL for easier shift calculation
      const originalHSL = hexToHSL(originalHex);
      const newHSL = hexToHSL(newHex);
      
      return {
        hueShift: newHSL.h - originalHSL.h,
        satShift: newHSL.s - originalHSL.s,
        lightShift: newHSL.l - originalHSL.l
      };
    }
    
    function applyColorShift(originalHex, shift, intensity = 1.0) {
      // Apply the shift to the original color with given intensity
      const originalHSL = hexToHSL(originalHex);
      
      let newH = originalHSL.h + (shift.hueShift * intensity);
      let newS = Math.max(0, Math.min(100, originalHSL.s + (shift.satShift * intensity)));
      let newL = Math.max(0, Math.min(100, originalHSL.l + (shift.lightShift * intensity)));
      
      // Handle hue wraparound
      if (newH < 0) newH += 360;
      if (newH >= 360) newH -= 360;
      
      return hslToHex(newH, newS, newL);
    }
    
    function hexToHSL(hex) {
      // Convert hex to RGB first
      const r = parseInt(hex.slice(1, 3), 16) / 255;
      const g = parseInt(hex.slice(3, 5), 16) / 255;
      const b = parseInt(hex.slice(5, 7), 16) / 255;
      
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      
      if (max === min) {
        h = s = 0; // achromatic
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      
      return {
        h: h * 360,
        s: s * 100,
        l: l * 100
      };
    }
    
    function reverseCalculateBaseColor(rule, derivedColor) {
      // This reverses the color calculation to find what base color would produce the derived color
      const hex = derivedColor.replace('#', '');
      let r = parseInt(hex.substr(0, 2), 16) / 255;
      let g = parseInt(hex.substr(2, 2), 16) / 255;
      let b = parseInt(hex.substr(4, 2), 16) / 255;
      
      // Apply gamma correction (approximate sRGB to linear)
      r = r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
      g = g <= 0.04045 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
      b = b <= 0.04045 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
      
      const derivedLightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;
      
      // Reverse the chroma adjustments first (if any)
      if (rule.Cmul !== 1 && rule.Cmul > 0) {
        const avgChannel = (r + g + b) / 3;
        r = avgChannel + (r - avgChannel) / rule.Cmul;
        g = avgChannel + (g - avgChannel) / rule.Cmul;
        b = avgChannel + (b - avgChannel) / rule.Cmul;
      }
      
      // Reverse the lightness calculation
      let baseLightness = derivedLightness;
      if (rule.Lmode === 'lighten') {
        baseLightness = Math.max(0, derivedLightness - rule.k);
      } else {
        baseLightness = Math.min(1, derivedLightness + rule.k);
      }
      
      // Apply ratio to get base color
      const ratio = derivedLightness > 0.001 ? baseLightness / derivedLightness : 1;
      let newR = r * ratio;
      let newG = g * ratio;
      let newB = b * ratio;
      
      // Clamp values
      newR = Math.max(0, Math.min(1, newR));
      newG = Math.max(0, Math.min(1, newG));
      newB = Math.max(0, Math.min(1, newB));
      
      // Convert back to sRGB
      newR = newR <= 0.0031308 ? newR * 12.92 : 1.055 * Math.pow(newR, 1/2.4) - 0.055;
      newG = newG <= 0.0031308 ? newG * 12.92 : 1.055 * Math.pow(newG, 1/2.4) - 0.055;
      newB = newB <= 0.0031308 ? newB * 12.92 : 1.055 * Math.pow(newB, 1/2.4) - 0.055;
      
      // Convert to hex
      const toHex = (c) => Math.round(Math.max(0, Math.min(255, c * 255))).toString(16).padStart(2, '0');
      return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
    }

    function hslToHex(h, s, l) {
      // Convert HSL to RGB, then to hex
      h = h / 360;
      s = s / 100;
      l = l / 100;
      
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      
      let r, g, b;
      if (s === 0) {
        r = g = b = l; // achromatic
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      
      const toHex = (c) => {
        const hex = Math.round(c * 255).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };
      
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    let variantCounter = 0;
    let availableAnchorColors = [];

    function showBatchSection() {
      if (selectedTemplateId) {
        document.getElementById('batch-section').style.display = 'block';
        initializeBatchSection();
        updateBatchButton();
      }
    }

    function hideBatchSection() {
      document.getElementById('batch-section').style.display = 'none';
      clearVariantList();
    }

    function initializeBatchSection() {
      const template = templates[selectedTemplateId];
      if (!template) return;

      // Get available anchor colors from template
      availableAnchorColors = Object.keys(template.originalColors || {});
      
      // Clear existing variants and add one default variant
      clearVariantList();
      addVariantRow();
    }

    function clearVariantList() {
      document.getElementById('variant-list').innerHTML = '';
      variantCounter = 0;
    }

    function addVariantRow() {
      const container = document.getElementById('variant-list');
      const variantId = ++variantCounter;
      
      const row = document.createElement('div');
      row.className = 'variant-row';
      row.dataset.variantId = variantId;
      
      // Get template color names for dropdown options
      const template = templates[selectedTemplateId];
      const colorOptions = availableAnchorColors.map(role => {
        const displayName = template?.colorNames?.[role] || role;
        return `<option value="${role}">${displayName}</option>`;
      }).join('');

      row.innerHTML = `
        <div class="variant-number">${variantId}</div>
        <select class="variant-anchor-dropdown input">
          ${colorOptions}
        </select>
        <input type="text" class="variant-color-input input" placeholder="#ff0000" maxlength="7">
        <button class="remove-variant-btn" data-variant-id="${variantId}" title="Remove variant">×</button>
      `;
      
      container.appendChild(row);
      
      // Add remove button event listener
      const removeBtn = row.querySelector('.remove-variant-btn');
      removeBtn.onclick = () => removeVariantRow(variantId);
      
      // Add input change listeners to update button state
      const colorInput = row.querySelector('.variant-color-input');
      const anchorSelect = row.querySelector('.variant-anchor-dropdown');
      
      colorInput.addEventListener('input', updateBatchButton);
      anchorSelect.addEventListener('change', updateBatchButton);
      
      updateBatchButton();
    }

    function removeVariantRow(variantId) {
      const row = document.querySelector(`[data-variant-id="${variantId}"]`);
      if (row) {
        row.remove();
        updateBatchButton();
      }
    }

    function collectVariantData() {
      const rows = document.querySelectorAll('.variant-row');
      const variants = [];
      
      rows.forEach((row, index) => {
        const name = `${index + 1}`; // Auto-number as 1, 2, 3, etc.
        const anchorColor = row.querySelector('.variant-anchor-dropdown').value;
        let hexColor = row.querySelector('.variant-color-input').value.trim();
        
        // Auto-add # if missing
        if (hexColor && !hexColor.startsWith('#') && hexColor.match(/^[0-9a-fA-F]{6}$/)) {
          hexColor = '#' + hexColor;
        }
        
        if (anchorColor && hexColor && hexColor.match(/^#[0-9a-fA-F]{6}$/)) {
          variants.push({ name, anchorColor, hexColor });
        }
      });
      
      return variants;
    }

    function updateBatchButton() {
      const button = document.getElementById('batch-generate');
      const variants = collectVariantData();
      button.disabled = !selectedTemplateId || variants.length === 0;
    }

    function hideColorPickers() {
      document.getElementById('color-picker-section').style.display = 'none';
      templateColors = {};
      updateApplyButton();
    }

    function updateApplyButton() {
      const button = document.getElementById('apply-template');
      button.disabled = !selectedTemplateId || Object.keys(templateColors).length === 0;
    }

    // Listen for messages from the plugin
    window.onmessage = (event) => {
      const { type, ...data } = event.data.pluginMessage || {};
      
      switch (type) {
        case 'selection-analyzed':
          displayAnalysisResults(data.layerColors);
          showStatus(`Found ${data.layerColors.length} colors in selection`);
          break;
        case 'template-created':
          showStatus('Template saved successfully! 🎨', 'success');
          break;
        case 'templates-updated':
          updateTemplateList(data.templates);
          break;
        default:
          break;
      }
    };

    // Initialize: request templates on load
    setTimeout(() => {
      postMessage('get-templates');
    }, 100);
</script>
</body>
</html>
